
<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="bauer_what_2019">Bauer, 2019</a>]
</td>
<td class="bibtexitem">
Bauer, A. (2019).
 What is algebraic about algebraic effects and handlers?
 <em>arXiv:1807.05923 [cs]</em>.
 arXiv: 1807.05923.
[&nbsp;<a href="algebraic_effects_montague_bib.html#bauer_what_2019">bib</a>&nbsp;| 
<a href="http://arxiv.org/abs/1807.05923">http</a>&nbsp;]
<blockquote><font size="-1">
This note recapitulates and expands the contents of a tutorial on the mathematical theory of algebraic effects and handlers which I gave at the Dagstuhl seminar 18172 "Algebraic effect handlers go mainstream". It is targeted roughly at the level of a doctoral student with some amount of mathematical training, or at anyone already familiar with algebraic effects and handlers as programming concepts who would like to know what they have to do with algebra. We draw an uninterrupted line of thought between algebra and computational effects. We begin on the mathematical side of things, by reviewing the classic notions of universal algebra: signatures, algebraic theories, and their models. We then generalize and adapt the theory so that it applies to computational effects. In the last step we replace traditional mathematical notation with one that is closer to programming languages.
</font></blockquote>
<blockquote><font size="-1">
Keywords: 08A70, Computer Science - Logic in Computer Science, Computer Science - Programming Languages
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="brady_programming_2013">Brady, 2013</a>]
</td>
<td class="bibtexitem">
Brady, E. (2013).
 Programming and reasoning with algebraic effects and dependent types.
 In <em>Proceedings of the 18th ACM SIGPLAN international
  conference on Functional programming</em>, ICFP '13, pages 133--144, New
  York, NY, USA. Association for Computing Machinery.
[&nbsp;<a href="algebraic_effects_montague_bib.html#brady_programming_2013">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2500365.2500581">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/2500365.2500581">http</a>&nbsp;]
<blockquote><font size="-1">
One often cited benefit of pure functional programming is that pure code is easier to test and reason about, both formally and informally. However, real programs have side-effects including state management, exceptions and interactions with the outside world. Haskell solves this problem using monads to capture details of possibly side-effecting computations --- it provides monads for capturing state, I/O, exceptions, non-determinism, libraries for practical purposes such as CGI and parsing, and many others, as well as monad transformers for combining multiple effects. Unfortunately, useful as monads are, they do not compose very well. Monad transformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad. In this paper I describe an alternative approach based on handling algebraic effects, implemented in the IDRIS programming language. I show how to describe side effecting computations, how to write programs which compose multiple fine-grained effects, and how, using dependent types, we can use this approach to reason about states in effectful programs.
</font></blockquote>
<blockquote><font size="-1">
Keywords: algebraic effects, dependent types
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="charlow_semantics_2014">Charlow, 2014</a>]
</td>
<td class="bibtexitem">
Charlow, S. (2014).
 <em>On the semantics of exceptional scope</em>.
 PhD Thesis, NYU, New York.
[&nbsp;<a href="algebraic_effects_montague_bib.html#charlow_semantics_2014">bib</a>&nbsp;| 
<a href="https://semanticsarchive.net/Archive/2JmMWRjY">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="charlow_static_2019">Charlow, 2019</a>]
</td>
<td class="bibtexitem">
Charlow, S. (2019).
 Static and dynamic exceptional scope.
 Publisher: Rutgers University Published: LingBuzz.
[&nbsp;<a href="algebraic_effects_montague_bib.html#charlow_static_2019">bib</a>&nbsp;| 
<a href="https://ling.auf.net/lingbuzz/004650">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="charlow_scope_2020">Charlow, 2020</a>]
</td>
<td class="bibtexitem">
Charlow, S. (2020).
 The scope of alternatives: indefiniteness and islands.
 <em>Linguistics and Philosophy</em>, 43(4):427--472.
[&nbsp;<a href="algebraic_effects_montague_bib.html#charlow_scope_2020">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/s10988-019-09278-3">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1007/s10988-019-09278-3">http</a>&nbsp;]
<blockquote><font size="-1">
I argue that alternative-denoting expressions interact with their semantic context by taking scope. With an empirical focus on indefinites in English, I show how this approach improves on standard alternative-semantic architectures that use point-wise composition to subvert islands, as well as on in situ approaches to indefinites more generally. Unlike grammars based on point-wise composition, scope-based alternative management is thoroughly categorematic, doesn’t under-generate readings when multiple sources of alternatives occur on an island, and is compatible with standard treatments of binding. Unlike all in situ (pseudo-scope) treatments of indefinites, relying on a true scope mechanism prevents over-generation when an operator binds into an indefinite. My account relies only on function application, some mechanism for scope-taking, and two freely-applying type-shifters: the first is Karttunen’s (Linguist Philos 1(1):3–44, 1977. https://doi.org/10.1007/BF00351935) proto-question operator, aka Partee’s (in: Groenendijk, de Jongh, Stokhof (eds) Studies in discourse representation theory and the theory of generalized quantifiers, Foris, Dordrecht, 1986) IDENT, and the second can be factored out of extant approaches to the semantics of questions in the tradition of Karttunen (1977). These type-shifters form a decomposition of LIFT, the familiar function mapping values into scope-takers. Exceptional scope of alternative-generating expressions arises via (snowballing) scopal pied-piping: indefinites take scope over their island, which then itself takes scope.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="degroote_towards_2006">de&nbsp;Groote, 2006</a>]
</td>
<td class="bibtexitem">
de&nbsp;Groote, P. (2006).
 Towards a Montagovian Account of Dynamics.
 <em>Semantics and Linguistic Theory</em>, 16(0):1--16.
 Number: 0.
[&nbsp;<a href="algebraic_effects_montague_bib.html#degroote_towards_2006">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.3765/salt.v16i0.2952">DOI</a>&nbsp;| 
<a href="https://journals.linguisticsociety.org/proceedings/index.php/SALT/article/view/2952">http</a>&nbsp;]
<blockquote><font size="-1">
No abstract.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="kiselyov_freer_2015">Kiselyov and Ishii, 2015</a>]
</td>
<td class="bibtexitem">
Kiselyov, O. and Ishii, H. (2015).
 Freer monads, more extensible effects.
 <em>ACM SIGPLAN Notices</em>, 50(12):94--105.
[&nbsp;<a href="algebraic_effects_montague_bib.html#kiselyov_freer_2015">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2887747.2804319">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/2887747.2804319">http</a>&nbsp;]
<blockquote><font size="-1">
We present a rational reconstruction of extensible effects, the recently proposed alternative to monad transformers, as the confluence of efforts to make effectful computations compose. Free monads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure. The end result is the algorithmically efficient extensible effects library, which is not only more comprehensible but also faster than earlier implementations. As an illustration of the new library, we show three surprisingly simple applications: non-determinism with committed choice (LogicT), catching IO exceptions in the presence of other effects, and the semi-automatic management of file handles and other resources through monadic regions. We extensively use and promote the new sort of `laziness', which underlies the left Kan extension: instead of performing an operation, keep its operands and pretend it is done.
</font></blockquote>
<blockquote><font size="-1">
Keywords: coroutine, effect handler, effect interaction, open union, type and effect system, free monad, Kan extension
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="kiselyov_extensible_2013">Kiselyov et&nbsp;al., 2013</a>]
</td>
<td class="bibtexitem">
Kiselyov, O., Sabry, A., and Swords, C. (2013).
 Extensible effects: an alternative to monad transformers.
 In <em>Proceedings of the 2013 ACM SIGPLAN symposium on
  Haskell</em>, Haskell '13, pages 59--70, New York, NY, USA. Association for
  Computing Machinery.
[&nbsp;<a href="algebraic_effects_montague_bib.html#kiselyov_extensible_2013">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2503778.2503791">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/2503778.2503791">http</a>&nbsp;]
<blockquote><font size="-1">
We design and implement a library that solves the long-standing problem of combining effects without imposing restrictions on their interactions (such as static ordering). Effects arise from interactions between a client and an effect handler (interpreter); interactions may vary throughout the program and dynamically adapt to execution conditions. Existing code that relies on monad transformers may be used with our library with minor changes, gaining efficiency over long monad stacks. In addition, our library has greater expressiveness, allowing for practical idioms that are inefficient, cumbersome, or outright impossible with monad transformers. Our alternative to a monad transformer stack is a single monad, for the coroutine-like communication of a client with its handler. Its type reflects possible requests, i.e., possible effects of a computation. To support arbitrary effects and their combinations, requests are values of an extensible union type, which allows adding and, notably, subtracting summands. Extending and, upon handling, shrinking of the union of possible requests is reflected in its type, yielding a type-and-effect system for Haskell. The library is lightweight, generalizing the extensible exception handling to other effects and accurately tracking them in types.
</font></blockquote>
<blockquote><font size="-1">
Keywords: coroutine, effect handler, effect interaction, monad, monad transformer, open union, type and effect system
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="marsik_effects_2016">Maršík, 2016</a>]
</td>
<td class="bibtexitem">
Maršík, J. (2016).
 <em>Effects and handlers in natural language</em>.
 phdthesis, Université de Lorraine.
[&nbsp;<a href="algebraic_effects_montague_bib.html#marsik_effects_2016">bib</a>&nbsp;| 
<a href="https://hal.inria.fr/tel-01417467">http</a>&nbsp;]
<blockquote><font size="-1">
In formal semantics, researchers assign meanings to sentences of a natural language. This work is guided by the principle of compositionality: the meaning of an expression is a function of the meanings of its parts. These functions are often formalized using the [lambda]-calculus. However, there are areas of language which challenge the notion of compositionality, e.g. anaphoric pronouns or presupposition triggers. These force researchers to either abandon compositionality or adjust the structure of meanings. In the first case, meanings are derived by processes that no longer correspond to pure mathematical functions but rather to context-sensitive procedures, much like the functions of a programming language that manipulate their context with side effects. In the second case, when the structure of meanings is adjusted, the new meanings tend to be instances of the same mathematical structure, the monad. Monads themselves being widely used in functional programming to encode side effects, the common theme that emerges in both approaches is the introduction of side effects. Furthermore, different problems in semantics lead to different theories which are challenging to unite. Our thesis claims that by looking at these theories as theories of side effects, we can reuse results from programming language research to combine them.This thesis extends [lambda]-calculus with a monad of computations. The monad implements effects and handlers, a recent technique in the study of programming language side effects. In the first part of the thesis, we prove some of the fundamental properties of this calculus: subject reduction, confluence and termination. Then in the second part, we demonstrate how to use the calculus to implement treatments of several linguistic phenomena: deixis, quantification, conventional implicature, anaphora and presupposition. In the end, we build a grammar that features all of these phenomena and their interactions.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="marsik_algebraic_2014">Maršík and Amblard, 2014</a>]
</td>
<td class="bibtexitem">
Maršík, J. and Amblard, M. (2014).
 Algebraic Effects and Handlers in Natural Language
  Interpretation.
 In Paiva, V.&nbsp;d., Neuper, W., Quaresma, P., Retoré, C., Moss, L.&nbsp;S.,
  and Saludes, J., editors, <em>Natural Language and Computer Science</em>,
  volume TR 2014-002 of <em>Joint Proceedings of the Second Workshop on
  Natural Language and Computer Science (NLCS'14) &amp; 1st
  International Workshop on Natural Language Services for Reasoners
  (NLSR 2014)</em>, Vienne, Austria. Center for Informatics and Systems of the
  University of Coimbra.
[&nbsp;<a href="algebraic_effects_montague_bib.html#marsik_algebraic_2014">bib</a>&nbsp;| 
<a href="https://hal.archives-ouvertes.fr/hal-01079206">http</a>&nbsp;]
<blockquote><font size="-1">
Phenomena on the syntax-semantics interface of natural languages have been observed to have links with programming language semantics, namely computa- tional effects and evaluation order. We explore this connection to be able to profit from recent development in the study of effects. We propose adopting algebraic effects and handlers as tools for facilitating a uniform and integrated treatment of different non-compositional phenomena on the syntax-semantics interface.
In this paper, we give an exposition of the framework of algebraic effects and handlers with an eye towards its applicability in computational semantics. We then present some exemplary analyses in the framework: we study the interplay of anaphora and quantification by translating the continuation-based dynamic logic of de Groote into a more DRT-like theory and we propose a treatment of overt wh-movement which avoids higher-order types in the syntax.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="marsik_introducing_2016">Maršík and Amblard, 2016</a>]
</td>
<td class="bibtexitem">
Maršík, J. and Amblard, M. (2016).
 Introducing a Calculus of Effects and Handlers for Natural
  Language Semantics.
 In Foret, A., Morrill, G., Muskens, R., Osswald, R., and Pogodalla,
  S., editors, <em>Formal Grammar</em>, Lecture Notes in Computer Science,
  pages 257--272, Berlin, Heidelberg. Springer.
[&nbsp;<a href="algebraic_effects_montague_bib.html#marsik_introducing_2016">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/978-3-662-53042-9_15">DOI</a>&nbsp;]
<blockquote><font size="-1">
In compositional model-theoretic semantics, researchers assemble truth-conditions or other kinds of denotations using the lambda calculus. It was previously observed [26] that the lambda terms and/or the denotations studied tend to follow the same pattern: they are instances of a monad. In this paper, we present an extension of the simply-typed lambda calculus that exploits this uniformity using the recently discovered technique of effect handlers [22]. We prove that our calculus exhibits some of the key formal properties of the lambda calculus and we use it to construct a modular semantics for a small fragment that involves multiple distinct semantic phenomena.
</font></blockquote>
<blockquote><font size="-1">
Keywords: Compositionality, Conventional implicature, Deixis, Handlers, Monads, Side effects
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="orchard_embedding_2014">Orchard and Petricek, 2014</a>]
</td>
<td class="bibtexitem">
Orchard, D. and Petricek, T. (2014).
 Embedding effect systems in Haskell.
 <em>ACM SIGPLAN Notices</em>, 49(12):13--24.
[&nbsp;<a href="algebraic_effects_montague_bib.html#orchard_embedding_2014">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2775050.2633368">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/2775050.2633368">http</a>&nbsp;]
<blockquote><font size="-1">
Monads are now an everyday tool in functional programming for abstracting and delimiting effects. The link between monads and effect systems is well-known, but in their typical use, monads provide a much more coarse-grained view of effects. Effect systems capture fine-grained information about the effects, but monads provide only a binary view: effectful or pure. Recent theoretical work has unified fine-grained effect systems with monads using a monad-like structure indexed by a monoid of effect annotations (called parametric effect monads). This aligns the power of monads with the power of effect systems. This paper leverages recent advances in Haskell's type system (as provided by GHC) to embed this approach in Haskell, providing user-programmable effect systems. We explore a number of practical examples that make Haskell even better and safer for effectful programming. Along the way, we relate the examples to other concepts, such as Haskell's implicit parameters and coeffects.
</font></blockquote>
<blockquote><font size="-1">
Keywords: effect systems, parametric effect monads, type systems
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="shan_monads_2002">Shan, 2002</a>]
</td>
<td class="bibtexitem">
Shan, C.-c. (2002).
 Monads for natural language semantics.
 <em>arXiv:cs/0205026</em>.
 arXiv: cs/0205026.
[&nbsp;<a href="algebraic_effects_montague_bib.html#shan_monads_2002">bib</a>&nbsp;| 
<a href="http://arxiv.org/abs/cs/0205026">http</a>&nbsp;]
<blockquote><font size="-1">
Accounts of semantic phenomena often involve extending types of meanings and revising composition rules at the same time. The concept of monads allows many such accounts -- for intensionality, variable binding, quantification and focus -- to be stated uniformly and compositionally.
</font></blockquote>
<blockquote><font size="-1">
Keywords: Computer Science - Programming Languages, Computer Science - Computation and Language, D.3.1, F.3.2, I.2.7
</font></blockquote>

</td>
</tr>
</table>