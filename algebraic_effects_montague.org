#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+HTML_HEAD: <script type="text/x-mathjax-config">
#+HTML_HEAD: MathJax.Hub.Config({
#+HTML_HEAD:  TeX: {
#+HTML_HEAD:    Macros: {
#+HTML_HEAD:      divd: "\\ |\\ ",
#+HTML_HEAD:      IF: ["[\\![#1]\\!]",1],
#+HTML_HEAD:      banana: ["(\\!|#1|\\!)",1],
#+HTML_HEAD:      bind: ">\\!\\!>\\!\\!=",
#+HTML_HEAD:      defeq: ":\\!=",
#+HTML_HEAD:      append: ["#1\\!\\!::\\!\\!#2",2]
#+HTML_HEAD:    }
#+HTML_HEAD:  }
#+HTML_HEAD: });
#+HTML_HEAD: </script>

#+Author: Julian Grove
#+Title: Algebraic effects in Montague semantics

Algebraic effects and handlers provide an approach to implementing computational side effects which has gained interest within the functional programming community, notably among users of Haskell.[fn:: Implementations in Haskell have generally gone by the title "extensible effects". See the libraries described in cite:kiselyov_extensible_2013 and cite:kiselyov_freer_2015, as well as the [[https://github.com/hasura/eff][eff]] library, for some examples. Algebraic effects and handlers have received implementations in other languages too, both pure and impure; e.g., see cite:brady_programming_2013 for Idris.] Often, programmers wish to combine different notions of side effect within the same code; for example, one may wish to write a program that both reads the environment at various points, as well as logs output. In Haskell, one may use the Reader and Writer monads to accomplish these tasks, respectively. Combining notions of side effect is, in turn, usually a matter of invoking monad transformers, which furnish some underlying monad with the functionality of a new monad, yielding aspects of both (e.g., a Reader-transformed Writer monad). The use of transformers, however, generally implies that code is not totally extensible --- extra plumbing is required, for instance, for Reader code to exist peacefully in a Reader-Writer setting.[fn:: One can browse Haskell's popular [[http://hackage.haskell.org/package/mtl][Monad Transformers Library]] for more details.] Moreover, after extending previous monadic code into a setting in which new layers have been added to the transformer stack, its interpretation becomes fixed: if the old code involes Reader $s_1$, and the new code involves both Reader $s_1$ and Reader $s_2$, then the Reader $s_2$ layer is necessarily evaluated first.  The interest in the algebraic effects approach comes, in part, from the fact that it is designed around extensibility: multiple notions of side effect are combined algebraically and tracked within the types. The combination is relatively seamless, moreover, in the sense that no extra plumbing is required for multiple notions of effect; and it is flexible, insofar as decisions about interpretation may be delayed until a later stage --- in the definitions of handlers.

In this post, I'll experiment a little bit with the algebraic approach in the context of modeling linguistic side effects. Jirka Maršík has done significant work studying semantic phenomena from the perspective of algebraic effects and handlers, culminating in his [[https://hal.inria.fr/tel-01417467][2016 PhD thesis]] (see cite:marsik_algebraic_2014,marsik_introducing_2016,marsik_effects_2016). This work, whose main features I'll briefly summarize in \S[[sec:algebraic effects]], is cast within a typed extension of the \lambda-calculus designed for algebraic effects. Maršík's work departs somewhat from the denotational view of meaning semanticists in the Montagovian tradition are typically accustomed to, at least on its face. He provides an operational semantics for the extended language, which includes operations and handlers, among other constructs. The semantics allows the representations provided in the extended language to be transformed into more familiar ones denoting ordinary truth-conditions (represented by simply typed \lambda-terms). The process of mapping expressions of the extended language into the STLC, however, involves sacrificing the usual Montagovian view of the meanings of their component parts.[fn:: Maršík also provides a set-theoretic denotational semantics for his calculus in chapter 3 of [[https://hal.inria.fr/tel-01417467][his thesis]]. It is not obvious, however, that this semantics can be given a simply typed encoding, at least not without special axioms; his $\mathcal{C}$ combinator, for instance, is a partial function.] 

I will mainly use this post is to explore how similar ideas may be expressed in a more traditional Montagovian setting. \S[[sec:making it montagovian]] begins an attempt in this direction with a framework having much of the functionality of the algebraic effects approach, cast within the simply typed \lambda-calculus (including products). The basic strategy explored is one which views algebraic operations as variables bound (and thus given meaning) by their handlers. This view of operations allows them to be recast as \lambda-abstractions, giving rise to an interpretation scheme on which operations denote functions on their handlers. The proposals have been implemented in Haskell, and relevant parts of the text are accompanied by their corresponding Haskell code. The full code is available [[https://github.com/juliangrove/algebraic-effects-montague][here]].

* Algebraic effects<<sec:algebraic effects>>

The basic features of Maršík's approach are presented in the papers cite:marsik_algebraic_2014,marsik_introducing_2016, as well as in the first chapter of [[https://hal.inria.fr/tel-01417467][his thesis]]. In addition to the expressions of the simply typed \lambda-calculus, Maršík includes the constructs /injection/, /operation/, /handler/, /extraction/, and /exchange/. Unlike the simply typed fragment of his language, these constructs have types involving (for value types $\alpha$) the computation types $\mathcal{F}(\alpha)$, providing the types of expressions with algebraic effects. The type of any computation with algebraic effects is indexed by an /effect signature/; that is, a set of operation symbols, along with an assignment of types to these operation symbols that indicate any parameters the associated operation takes, as well as the operation's arity. The signature that indexes the type of a computation describes the collection of operations that /may/ be invoked in the computation. For example, the computation type $\mathcal{F}_{\{\mathtt{op} : p ⤚ a\}}(\alpha)$ is the type of computations which may invoke the operation $\mathtt{op}$ (which takes parameters of type $p$ and which has arity $a$), in order to return values of type $\alpha$.  

Where $E$ is an arbitrary effect signature and $\varnothing$ is the empty effect signature, the constructs of /injection/, /operation/, /handler/, /extraction/, and /exchange/ have the following typing rules. (I've modified some symbols from Maršík's original presentation so that they more easily render with [[https://www.mathjax.org/][MathJax]].)

$$\cfrac{\Gamma \vdash M : \alpha}{\Gamma \vdash \eta M : \mathcal{F}_E(\alpha)}\eta\tag{injection}\\[3mm]$$
$$\cfrac{\Gamma \vdash M : p\hspace{5mm}\Gamma, x : a \vdash N : \mathcal{F}_E(\gamma)\hspace{5mm}\mathtt{op}_{p ⤚ a} \in E}{\Gamma \vdash \mathtt{op} M (\lambda x. N) : \mathcal{F}_E(\gamma)}\mathtt{op}\tag{operation}\\[3mm]$$
$$\cfrac{E = \{\mathtt{op}_i : p_i ⤚ a_i\}_{i \in I} \uplus E_f\\E^\prime = E^{\prime\prime} \uplus E_f\\{[}\Gamma \vdash M_i : p_i \rightarrow (a_i \rightarrow \mathcal{F}_{E^\prime}(\delta)) \rightarrow \mathcal{F}_{E^\prime}(\delta){]}_{i \in I}\\\Gamma \vdash N : \gamma \rightarrow \mathcal{F}_{E^\prime}(\delta)\\\Gamma \vdash O : \mathcal{F}_E(\gamma)}{\Gamma \vdash \banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N} O : \mathcal{F}_{E^\prime}(\delta)}\banana{}\tag{handler}\\[3mm]$$
$$\cfrac{\Gamma \vdash M : \mathcal{F}_\varnothing(\alpha)}{\Gamma \vdash ⇓ M : \alpha}⇓\tag{extraction}\\[3mm]$$
$$\cfrac{\Gamma \vdash M : \alpha \rightarrow \mathcal{F}_E(\beta)}{\Gamma \vdash \mathcal{C} M : \mathcal{F}_E(\alpha \rightarrow \beta)}\mathcal{C}\tag{exchange}$$

The type of an injection is such that it may be associated with any signature $E$; in other words, values of type $\alpha$ may be injected into any algebra, no matter what signature it has, as a trivial computation which simply returns that value.

Explaining the typing rule for operations requires elaborating a few background conventions. The premise $\mathtt{op}_{p ⤚ a} \in E$ indicates that operation $\mathtt{op}$ takes a parameter of type $p$ and has arity $a$; that is, it first applies to a term of type $p$ and then takes $a$ -many elements of the algebra, i.e., $a$ -many arguments of type $\mathcal{F}_E(\gamma)$, for some value type $\gamma$. As $a$ is a type (rather than a cardinality), we simply follow the convention that having arity $a$ is equivalent to being able to apply to an $a$ -indexed family of elements of the algebra, or, in other words, to a function of type $a \rightarrow \mathcal{F}_E(\gamma)$. Thus a binary operation, for example, may be thought of as one which applies to a $\mathtt{Bool}$ -indexed family of elements, where $\mathtt{Bool}$ is the type with two inhabitants: $\mathtt{True}$ and $\mathtt{False}$. And a unary operation may be thought of as one which applies to a $\star$ -indexed family of elements, where $\star$ is the unit type, having one element (also called $\star$). (See cite:bauer_what_2019 for a really great, accessible introduction to the relationship between algebra, as traditionally conceived, and as a framework for theories of computation.) In these terms, the typing rule for operations may be read as saying that if $\mathtt{op}$ takes a parameter of type $p$, along with $a$ -many arguments of an algebra with signature $E$ containing the operation, and there is a term $M$ of type $p$, as well as a way of determining an element $N$ of the algebra $\mathcal{F}_E(\gamma)$ for each index $x : a$, then one may apply the operation to the parameter $M$ and the $a$ -indexed family of elements $\lambda x.N$ to get a new element of the algebra.

The typing rule for handlers appears the most complex. In it, $\uplus$ denotes disjoint union (of effect signatures), and $I$ is some set indexing a set of judgments of the form presented in the third premise. In all, the typing rule says (approximately) that if there are terms $M_i$ taking parameters of type $p_i$ and $a_i$ -many arguments from an algebra with some effect signature $E^\prime$ (where $E^\prime$ is required to contain any operations that will /not/ be handled by the $M_i$), along with a term $N$ mapping values of type $\gamma$ into this algebra, then the handler that interprets operations $\mathtt{op}_i$ with $M_i$ and $\eta x$ with $N x$ can be applied to a computation $O$ from an algebra which has the operations $\mathtt{op}_i$ in its signature, in order to get an element of the new algebra with signature $E^\prime$. In summary, handlers can apply to elements of one algebra to obtain elements of another algebra by providing terms to interpret the operations of the first as functions in the second.

The typing rules for extraction and exchange are straightforward. Extraction applies to a computation whose effect signature is empty, and thus which is guaranteed to only return a value; its role, as reflected in its type, is to extract that value from the computation. Exchange applies to a function from a value to a computation, in order to deliver a computation of a function between values. Maršík uses this construct to assist with the semantics of quantifiers.

Let's illustrate the approach with an example involving quantifiers. Note that I won't present Maršík's analysis of quantification, even though I'll make use of the formal language he provides. The example is meant only to be expository. We start by introducing an operator $\mathtt{scope}$ with the type $(e \rightarrow t) \rightarrow t ⤚ e$; i.e., which takes a parameter of type $(e \rightarrow t) \rightarrow t$ (a standard generalized quantifier meaning) and has arity $e$ (meaning it takes a continuation of type $e \rightarrow \mathcal{F}_E(\gamma)$, where $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} \in E$).[fn:: Maršík provides an operator called $\mathtt{scope}$ with a similar purpose; its type is crucially different, however, insofar as he divides the work up differently between the operator and its handler.] Using this operator, we can analyze /every/ as denoting a function from predicates to computations which return values of type $e$.

$$\begin{align*}
\IF{\textit{every}} &: (e \rightarrow t) \rightarrow \mathcal{F}_E(e)\ \ (\text{where}\ \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} \in E)\\
\IF{\textit{every}} &= \lambda P.\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.P x \rightarrow k x) (\lambda x.\eta x)
\end{align*}$$

As a result, noun phrases like /every dog/ denote computations, derived by Functional Application, which return values of type $e$. In other words, they denote elements of an algebra whose signature contains the operator $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$ and which is generated by the type $e$.

$$\begin{align*}
\IF{\textit{every dog}} &: \mathcal{F}_E(e)\ \ (\text{where}\ \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} \in E)\\
\IF{\textit{every dog}} &= \IF{\textit{every}} \IF{\textit{dog}}\\
&= \IF{\textit{every}} \textbf{dog}\\
&= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta x)
\end{align*}$$

Given this noun phrase, we would like a way of composing it with a verb --- say, /barked/ --- in order to arrive at a sentence meaning. In fact, computations with algebraic effects can be composed using /monads/. Each algebraic effect signature gives rise to monad in the following way. First, the /return/ (i.e., $(\cdot)^\eta$) of the monad corresponds to the /injection/ in the relevant algebra.

$$\begin{align*}
(\cdot)^\eta &: v \rightarrow \mathcal{F}_E(v)\\
v^\eta &= \eta v
\end{align*}$$

Note that the $(\cdot)^\eta$ on the left-hand-side of the above definition is the return of the monad, and that the $\eta$ on the right-hand-side is the injection of the algebra. The /bind/ (i.e., $\bind$) of the monad may be defined by induction on the algebraic operations, i.e., in terms of an /injection/ case and an /operation/ case.

$$\begin{align*}
(\bind) &: \mathcal{F}_E(v) \rightarrow (v \rightarrow \mathcal{F}_E(w)) \rightarrow \mathcal{F}_E(w)\\
\eta v \bind k &= k v\tag{injection}\\
\mathtt{op} M N \bind k &= \mathtt{op} M (\lambda x.N x \bind k)\tag{operation}
\end{align*}$$

Using monadic $(\cdot)^\eta$ and $\bind$, we may compose /every dog/ and /barked/ (the latter of which we may take to denote $\textbf{bark} : e \rightarrow t$) in the familiar way; that is, by lifting the meaning of the verb and composing it with the noun phrase in terms of forward and backward monadic Functional Application ($\triangleright$ and $\triangleleft$).[fn:: See cite:shan_monads_2002 and cite:charlow_semantics_2014 for general approaches along such lines.]

$$\begin{align*}
(\triangleright) &: \mathcal{F}_E(v \rightarrow w) \rightarrow \mathcal{F}_E(v) \rightarrow \mathcal{F}_E(w)\\
m \triangleright n &= m \bind \lambda f.n \bind \lambda x.(f x)^\eta\\[3mm]
(\triangleleft) &: \mathcal{F}_E(v) \rightarrow \mathcal{F}_E(v \rightarrow w) \rightarrow \mathcal{F}_E(w)\\
m \triangleleft n &= m \bind \lambda x.n \bind \lambda f.(f x)^\eta
\end{align*}$$

We may now derive the meaning of /every dog barked/ as follows.

$$\begin{align*}
\IF{\textit{every dog barked}} &: \mathcal{F}_E(t)\ \ (\textit{where}\ \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} \in E)\\
\IF{\textit{every dog barked}} &= \IF{\textit{every dog}} \triangleleft \IF{\textit{barked}}\\
&= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta x) \bind \lambda y.\textbf{bark}^\eta \bind \lambda f.(f y)^\eta\\
&= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta x \bind \lambda y.\textbf{bark}^\eta \bind \lambda f.(f y)^\eta)\\
&= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\textbf{bark}^\eta \bind \lambda f.(f x)^\eta)\\
&= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta \textbf{bark}\bind \lambda f.(f x)^\eta)\\
&= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.(\textbf{bark} x)^\eta)\\
&= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta (\textbf{bark} x))\\
\end{align*}$$

What we end up with is a computation that returns a value of type $t$. In order to interpret this computation in the simply typed \lambda-calculus, Maršík's system allows us to define a handler, which we may, in turn, invoke as a kind of type shift that applies at the sentence level. Let's call this type shift $\mathtt{handleScope}$ for short.

$$\begin{align*}
\mathtt{handleScope} &: \mathcal{F}_{\{\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}\}}(t) \rightarrow t\\
\mathtt{handleScope} m &= \Downarrow (\banana{\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} : \lambda Q, k.\eta (Q (\Downarrow (\mathcal{C} k))), \eta : \lambda x.\eta x} m)
\end{align*}$$

Indeed, it can be deduced from the typing rules for /handler/, /extraction/, and /exchange/ that $\mathtt{handleScope}$ has the type indicated. What we're currently lacking is the relevant operational semantics for these constructs; let's provide it now (repeating Maršík's definitions).

$$\begin{align*}
\banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N} (\eta O) &\Rightarrow N O\tag{handler}\\[3mm]
\banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N} (\mathtt{op}_j p k) &\Rightarrow M_j p (\lambda x.\banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N} (k x))\tag{handler}\\
&(\text{where}\ j \in I\ \text{and}\ x \notin fv((M_i)_{i \in I}, N))\\[3mm]
\banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N} (\mathtt{op}_j p k) &\Rightarrow \mathtt{op}_j p (\lambda x.\banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N} (k x))\tag{handler}\\
&(\text{where}\ j \notin I\ \text{and}\ x \notin fv((M_i)_{i \in I}, N))
\end{align*}$$

The semantics for handlers describes their behavior in three situations. The first situation is that in which the handler applies to a returned value, in which case, its $\eta$ clause applies. In particular, if the handler handles returned values with the term $N$ (as indicated inside the banana brackets), then handling a returned value with the handler is just a matter of applying $N$ to it. The second situation is that in which the handler applies to an operation that it handles. In this case, the operation is interpreted as the handler dicates, and the handler continues to apply to the operation's arguments. The third situation is that in which the handler applies to an operation that it doesn't handle, in which case, the operation is ignored, and the handler continues to apply to the operation's arguments.

Let's now consider the semantics of /extraction/.

$$\begin{align*}
\Downarrow (\eta v) &\Rightarrow v\tag{extraction}
\end{align*}$$

Thus extraction simply extracts a value out of the algebra in which it is embedded.

Finally, /exchange/.

$$\begin{align*}
\mathcal{C} (\lambda x.\eta v) &\Rightarrow \eta (\lambda x.v)\tag{exchange}\\[3mm]
\mathcal{C} (\lambda x.\mathtt{op} p k) &\Rightarrow \mathtt{op} p (\lambda y.\mathcal{C} (\lambda x. k y))\tag{exchange}\\
&(\text{where}\ x \notin fv(p))
\end{align*}$$

Thus exchange turns an arrow of type $\alpha \rightarrow \mathcal{F}_E(\beta)$ into a computation of type $\mathcal{F}_E(\alpha \rightarrow \beta)$ by recursively commuting the index with the constructors of the calculus. As a result, exchange is a partial operation, applicable only if the index doesn't occur free in any of the parameters invoked inside the computation. 

Given these additions, we may handle the sentence /every dog barked/ using $\mathtt{handleScope}$. Note that, to save space, we're skipping the step in which $\eta$ is handled, since handling in that case is trivial (i.e., it involves simply replacing $\eta$ with itself).

$$\begin{align*}
&\mathtt{handleScope} \IF{\textit{every dog barked}}\\
=\ &\mathtt{handleScope} (\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta (\textbf{bark} x)))\\
=\ &\Downarrow (\banana{\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} : \lambda Q, k.\eta (Q (\Downarrow (\mathcal{C} k))), \eta : \lambda x.\eta x}\\
&\hspace{2cm}(\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta (\textbf{bark} x))))\\
=\ &\Downarrow ((\lambda Q, k^\prime.\eta (Q (\Downarrow (\mathcal{C} k^\prime)))) (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\eta (\textbf{bark} x)))\\
=\ &\Downarrow ((\lambda k^\prime.\eta ((\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\Downarrow (\mathcal{C} k^\prime)))) (\lambda x.\eta (\textbf{bark} x)))\\
=\ &\Downarrow (\eta ((\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\Downarrow (\mathcal{C} (\lambda x.\eta (\textbf{bark} x))))))\\
=\ &\Downarrow (\eta ((\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\Downarrow (\eta (\lambda x.\textbf{bark} x)))))\\
=\ &\Downarrow (\eta ((\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda x.\textbf{bark} x)))\\
=\ &\Downarrow (\eta (\forall x.\textbf{dog} x \rightarrow \textbf{bark} x))\\
=\ &\forall x.\textbf{dog} x \rightarrow \textbf{bark} x
\end{align*}$$

In the end, we've arrived at an ordinary formula of first-order logic representing the usual denotation assigned to /every dog barked/. We got there by first invoking the $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$ operation via the noun phrase, then composing the sentence meaning using monadic composition, and, finally, handling the operation using $\mathtt{handleScope}$. Importantly, we could have invoked $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$ any number of times; e.g., twice, as in /every dog chased every cat/. Applying the handler would have resulted in the first instance of $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$ being handled, followed by the second instance.

So far, we have illustrated the algebraic approach to linguistic side effects in terms of an algebraic signature with only one operation, $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$. We'll soon look at a grammar invoking a signature with several operations, but let's first see how we can make the above approach to semantic composition look a little more familiar to the average Montague-style semanticist.

* Making it Montagovian<<sec:making it montagovian>>

We'll attempt here to render some of the ideas illustrated above in the more familiar setting provided by the simply typed \lambda-calculus (with products). The proposals of this section have been implemented as runnable Haskell code, which is available in full [[https://github.com/juliangrove/algebraic-effects-montague][here]], and relevant parts of which are presented throughout. Note that the following language pragmas are needed for the implementation of algebraic effects and handlers.

#+BEGIN_SRC haskell
{-# LANGUAGE
    DataKinds,
    FlexibleInstances,
    GADTs,
    InstanceSigs,
    MultiParamTypeClasses,
    RankNTypes,
    ScopedTypeVariables,
    TypeApplications,
    TypeFamilies,
    TypeOperators,
    UndecidableInstances #-}
#+END_SRC

** Computation types

To start, we'll define our computation types as values of a function $\mathcal{F}_l(v)$, where $l$ is a parameter consisting of a list of types of the form $p_i ⤚ a_i$. $\mathcal{F}_l(v)$ is defined as follows, where $\epsilon$ is the empty list, and $o$ is an arbitrary type. (Thus, fixing $v$, computation types act like equivalence classes of simple types that are agnostic about what $o$ is).
 
$$\begin{align*}
\mathcal{F}_{\epsilon}(v) &= v\\
\mathcal{F}_{p ⤚ a, l}(v) &= (p \rightarrow (a \rightarrow \mathcal{F}_l(v)) \rightarrow o) \rightarrow o
\end{align*}$$

Thus any computation whose type is derived from the parameter $\epsilon$ is trivial; it just returns a value. To see what a computation whose type is derived from a complex parameter looks like, let's consider the parameter $(e \rightarrow t) \rightarrow t ⤚ e, (e \rightarrow t) \rightarrow t ⤚ e$. Any such computation is a \lambda-term of the following type.

$$\begin{align*}
&\mathcal{F}_{(e \rightarrow t) \rightarrow t ⤚ e, (e \rightarrow t) \rightarrow t ⤚ e}(v)\\
=\ \ &(((e \rightarrow t) \rightarrow t ) \rightarrow (e \rightarrow \mathcal{F}_{(e \rightarrow t) \rightarrow t ⤚ e}(v)) \rightarrow o) \rightarrow o\\
=\ \ &(((e \rightarrow t) \rightarrow t ) \rightarrow (e \rightarrow (((e \rightarrow t) \rightarrow t ) \rightarrow (e \rightarrow \mathcal{F}_\epsilon(v) \rightarrow o^\prime) \rightarrow o^\prime) \rightarrow o) \rightarrow o\\
=\ \ &(((e \rightarrow t) \rightarrow t ) \rightarrow (e \rightarrow (((e \rightarrow t) \rightarrow t ) \rightarrow (e \rightarrow v \rightarrow o^\prime) \rightarrow o^\prime) \rightarrow o) \rightarrow o
\end{align*}$$

If we set $v$ to the type $t$ of truth values, a term of this type might be the following one. (As will become evident, this term represents the meaning of the sentence /every dog chased every cat/.)

$$\lambda h.h (\lambda k.\forall x.\textbf{dog} x \rightarrow k x) (\lambda y, h^\prime.h^\prime (\lambda k.\forall x.\textbf{cat} x \rightarrow k x) (\lambda z.\textbf{chase} z y))$$

Such a format for representing computations may look reminiscent of the system presented in \S[[sec:algebraic effects]], but with two crucially new conventions. First, operations are now represented by \lambda-abstracted variables. The choice of variable name $h$ is meant to suggest that operations act as functions on their handlers; indeed, interpreting an operation in terms of a handler, from this perspective, is just a matter of passing the handler to the operation (encoded as a \lambda-abstraction). Second, the parameters of computation types now explicitly represent how many times particular operations are invoked, and in what order. The computation type $\mathcal{F}_{(e \rightarrow t) \rightarrow t ⤚ e, (e \rightarrow t) \rightarrow t ⤚ e}(t)$, for instance, is the type of a computation which invokes the $\mathtt{scope}$ operation /twice/ before returning a value of type $t$.

Thus there is a somwhat indirect relationship between the parameter $l$ of a computation type $\mathcal{F}_l(v)$ and an algebraic signature: the parameter describes the operations invoked in a computation (in the order in which they are invoked) and, hence, the operations contained in the smallest algebraic signature with which the computation is compatible. The parameter $\epsilon$ indicates that no operations are invoked; such a computation (which merely returns a value) is thus compatible with /any/ algebraic signature. Meanwhile, the parameter $p_1 ⤚ a_1, \ldots, p_n ⤚ a_n$ indicates that operations with those types are invoked (in that order); such a computation is compatible with any algebraic signature, as long as it contains operations with the types $p_1 ⤚ a_1, \ldots, p_n ⤚ a_n$.

In Haskell, we may encode $\mathcal{F}_l(v)$ as a generalized algebraic data type.

#+BEGIN_SRC haskell
-- | The data type of effectful computations.
data F l v where
  Pure :: v -> F '[] v
  Impure :: (forall o . (p -> (a -> F l v) -> o) -> o) -> F (p >-- a ': l) v
#+END_SRC

We have two constructors: /Pure/, for trivial (i.e., pure) computations that return values, and /Impure/, for those which invoke an operation before continuing with the rest of the computation. Note that we invoke explicit quantification over the type $o$ to encode the GADT, rather than simply allow it to be arbitrary, as above. Type-quantificationais a necessary feature of the Haskell implementation, since the GADT would otherwise hide the type $o$, forcing on it an existential interpretation.

Given our encoding of computations with algebraic effects into the simply typed \lambda-calculus, we ought to provide a way of composing them analogous to what we had in \S[[sec:algebraic effects]]. Fortunately, the relevant compositional scheme is straightforward: just as algebraic effects normally give rise to monads, our encoding gives rise to graded monads.

** Graded monads

Graded monads generalize monads in order to associate with each computation type an /effect/ that parameterizes it with fine-grained information about the nature of the relevant side effect. Concretely, a graded monad is a family of functors $G : \mathcal{E} \rightarrow \mathcal{T} \rightarrow \mathcal{T}$, parameterized by a monoid $\mathcal{E}$ of effects. Then given some $e \in \mathcal{E}$, $G_e$ is an endofunctor on the category $\mathcal{T}$ of types. Associated with each graded monad are two operators, $(\cdot)^\eta$ and $\bind$, having the following type-signatures (where $\mathtt{0}$ and $+$ are, respectively, the identity and associative operation of the monoid $\mathcal{E}$).

$$\begin{align*}
(\cdot)^\eta &: v \rightarrow G_\mathtt{0}(v)\\
(\bind) &: G_e(v) \rightarrow (v \rightarrow G_f(w)) \rightarrow G_{e+f}(w)
\end{align*}$$

These operators are required to satisfy the /graded monad laws/, which are identical in form to the laws for ordinary monads, modulo the manipulation of effects.[fn:: In particular, the laws entail that the parameters form a monoid, as stipulated.]

In our case, the relevant graded monad consists of the function $\mathcal{F} : \mathcal{T}^* \rightarrow \mathcal{T} \rightarrow \mathcal{T}$, whose effects are given by $\mathcal{T}^*$, the free monoid (i.e., of lists) over $\mathcal{T}$ (viewed as a set). Given any effect $l$, $\mathcal{F}_l$ is indeed a functor, as witnessed by the following definition of $\mathtt{map}_{\mathcal{F}_l}$.

$$\begin{align*}
\mathtt{map}_{\mathcal{F}_l} &: (v \rightarrow w) \rightarrow \mathcal{F}_l(v) \rightarrow \mathcal{F}_l(w)\\
\mathtt{map}_{\mathcal{F}_\epsilon} f v &= f v\tag{injection}\\
\mathtt{map}_{\mathcal{F}_{p ⤚ a, l}} f m &= \lambda h.m (\lambda p, k.h p (\lambda a.\mathtt{map}_{\mathcal{F}_l} f (k a)))\tag{operation}
\end{align*}$$

(Accordingly, we may write the following /Functor/ instance in Haskell.)

#+BEGIN_SRC haskell
-- | For any effect l, F l is a /Functor/.
instance Functor (F l) where
  fmap f (Pure v) = Pure $ f v
  fmap f (Impure m) = Impure $ \h -> m $ \p k -> h p (\a -> fmap f $ k a)
#+END_SRC

The fact that $\mathcal{F}$ is a graded monad is exhibited, first, by the following definition of $(\cdot)^\eta$,

$$\begin{align*}
(\cdot)^\eta &: v \rightarrow \mathcal{F}_\epsilon(v)\\
v^\eta &= v
\end{align*}$$

and second, by the following definition of $\bind$.

$$\begin{align*}
(\bind) &: \mathcal{F}_{l_1}(v) \rightarrow (v \rightarrow \mathcal{F}_{l_2}(w)) \rightarrow \mathcal{F}_{l_1, l_2}(w)\\
v \bind k &= k v\tag{injection}\\
m \bind k &= \lambda h.m (\lambda p, k^\prime.h p (\lambda a.k^\prime a \bind k))\tag{operation}
\end{align*}$$

In Haskell, we may write the corresponding instance for the /Effect/ class of cite:orchard_embedding_2014 for graded monads. /(:++)/, which provides the associative operation of the relevant monoid, is concatenation on type-level lists.

#+BEGIN_SRC haskell
-- | Computations with algebraic effects form a graded monad.
instance Effect F where
  type Unit F = '[] -- The monoidal unit.
  type Plus F l1 l2 = l1 :++ l2 -- The monoidal associative operation.

  return :: v -> F '[] v
  return v  = Pure v

  (>>=) :: F l1 v -> (v -> F l2 w) -> F (l1 :++ l2) w
  Pure v >>= k = k v -- (injection)
  Impure m >>= k = Impure $ \h -> m $ \p k' -> h p (\a -> k' a >>= k) -- (operation)
#+END_SRC

** Operations

At this point, it is useful to define the operations that will be the basis of the linguistic example presented \S[[sec:a linguistic example]]. We can understand operations associated with the type $p ⤚ a$ as simply typed \lambda-terms with the following type (where $v$ is an arbitrary value type and $l$ may be any effect).

$$p \rightarrow (a \rightarrow \mathcal{F}_l(v)) \rightarrow \mathcal{F}_{p ⤚ a, l}(v)$$

#+BEGIN_SRC haskell
-- | The type of an operation taking parameter p and a-many arguments.
type Operation p a = forall l v . p -> (a -> F l v) -> F (p >-- a ': l) v
#+END_SRC

Any given operation will therefore be rendered as a \lambda-term with the following shape.

$$\begin{align*}
\mathtt{op}_{p ⤚ a} &: p \rightarrow (a \rightarrow \mathcal{F}_l(v)) \rightarrow \mathcal{F}_{p ⤚ a, l}(v)\\
\mathtt{op}_{p ⤚ a}(p; k) &= \lambda h.h p k
\end{align*}$$

#+BEGIN_SRC haskell
-- | Operations take a parameter, p, and a-many arguments. Handlers then use the
-- parameter to choose which arguments they will further handle.
op :: Operation p a
op p k = Impure $ \h -> h p k
#+END_SRC

Given a parameter $p$ and a continuation $k$ (associated with arity $a$), the operation builds a new computation, i.e., element of an algebra whose signature is compatible with the effect $p ⤚ a, l$. Any given operation is associated with a /computation/ that simply invokes the operation on some parameter and returns a result. Given an operation associated with the type $p ⤚ a$, and a parameter $p$ (of type $p$), the corresponding computation is given by the following abbreviation $\mathtt{comp}_{p ⤚ a}$.

$$\begin{align*}
\mathtt{comp}_{p ⤚ a} &: p \rightarrow \mathcal{F}_{p ⤚ a}(a)\\
\mathtt{comp}_{p ⤚ a} p &= \mathtt{op}_{p ⤚ a}(p; \lambda a.a)
\end{align*}$$

#+BEGIN_SRC haskell
-- | The type of a computation consisting of a single operation.
type Computation p a = p -> F '[p >-- a] a

-- | Computations (of one operation) just perform the operation and return the
-- result.
comp :: Computation p a
comp p = op p return
#+END_SRC

That is, the computation invokes the operation and continues with the /return/ of the graded monad. Any operation may then be recovered from its associated computation by binding it to the relevant continuation, i.e., as

$$\mathtt{op}_{p ⤚ a}(p; k) = \mathtt{comp}_{p ⤚ a} p \bind k$$

For the linguistic example we consider in \S[[sec:a linguistic example]], we will deal specifically with the operations associated with /state/ (\S[[sec: state]]) and /quantification/ (\S[[sec: quantification]]).

*** State<<sec: state>>

The state algebra consists of operations for reading from and writing to an environment of some designated type. Given a type $s$ of the environment, there are two state operations, $\mathtt{get}_{\star ⤚ s}$, which reads from the environment, and $\mathtt{put}_{s ⤚ \star}$, which writes to the environment. (Recall that $\star$ is the unit type; it is inhabited by a single element, also called $\star$.) In our linguistic example, we'll use these operations to manage anaphora. Thus we can take the environment to be a list of individuals, whose type we'll call $\gamma$ (following cite:degroote_towards_2006).

$$\begin{align*}
\mathtt{get}_{\star ⤚ \gamma} &: \star \rightarrow (\gamma \rightarrow \mathcal{F}_l(v)) \rightarrow \mathcal{F}_{\star ⤚ \gamma, l}(v)\\
\mathtt{get}_{\star ⤚ \gamma}(\star; k) &= \lambda h.h \star k\\[3mm]
\mathtt{put}_{\gamma ⤚ \star} &: \gamma \rightarrow (\star \rightarrow \mathcal{F}_l(v)) \rightarrow \mathcal{F}_{\gamma ⤚ \star, l}(v)\\
\mathtt{put}_{\gamma ⤚ \star}(g; k) &= \lambda h.h g k
\end{align*}$$

$\gamma$ corresponds, in Haskell, to the type of lists of entities.

#+BEGIN_SRC haskell
get :: Operation () [Entity]
get = op

put :: Operation [Entity] ()
put = op
#+END_SRC

Corresponding to these operations are their associated computations, which, we'll call $\mathtt{get}^\prime_{\star ⤚ \gamma}$ and $\mathtt{put}^\prime_{\gamma ⤚ \star}$.

$$\begin{align*}
\mathtt{get}^\prime_{\star ⤚ \gamma} &: \star \rightarrow \mathcal{F}_{\star ⤚ \gamma}(\gamma)\\
\mathtt{get}^\prime_{\star ⤚ \gamma} \star &= \mathtt{get}_{\star ⤚ \gamma}(\star; \lambda g.g)\\
&= \lambda h.h \star (\lambda g.g)\\[3mm]
\mathtt{put}^\prime_{\gamma ⤚ \star} &: \gamma \rightarrow \mathcal{F}_{\gamma ⤚ \star}(\star)\\
\mathtt{put}^\prime_{\gamma ⤚ \star} g &= \mathtt{put}_{\gamma ⤚ \star}(g; \lambda\star.\star)\\
&= \lambda h.h g (\lambda\star.\star)
\end{align*}$$

#+BEGIN_SRC haskell
get' :: Computation () [Entity]
get' = comp

put' :: Computation [Entity] ()
put' = comp
#+END_SRC

In terms of these, we can write a simple program, $(\cdot)^\triangleright$ (called 'bind'), which, given a computation returning an entity, reads the environment and updates it by making the returned entity live for anaphora. (The function $\append{\ }{\ }$ is used to append an entity (on the left) to the environment (on the right).)

$$\begin{align*}
(\cdot)^\triangleright &: \mathcal{F}_l(e) \rightarrow \mathcal{F}_{l, \star ⤚ \gamma, \gamma ⤚ \star}(e)\\
m^\triangleright &= m \bind \lambda x.\mathtt{get}^\prime_{\star ⤚ \gamma} \star \bind \lambda g.\mathtt{put}^\prime_{\gamma ⤚ \star} (\append{x}{g}) \bind \lambda\star.x\\
(\ &= m \bind \lambda x.\mathtt{get}_{\star ⤚ \gamma}(\star; \lambda g.\mathtt{put}_{\gamma ⤚ \star}(\append{x}{g}; \lambda\star.x))\ \ )\\
(\ &= m \bind \lambda x, h.h \star (\lambda g, h^\prime.h^\prime (\append{x}{g}) (\lambda\star.x))\ \ )
\end{align*}$$

#+BEGIN_SRC haskell
-- | Make a computation returning an 'Entity' live for anaphora.
bind :: F l Entity -> F (l :++ [() >-- [Entity], [Entity] >-- ()]) Entity
bind m = m >>= \x ->
	   get' () >>= \g ->
	   put' (x:g) >>
	   return x
#+END_SRC

Thus $(\cdot)^\triangleright$ reads in the entity returned by its input, gets the current environment, puts a new environment (consisting of the entity appended to the old environment), and, finally, returns the entity again. Note that the effect associated with the resulting computation is just whatever the effect $l$ associated with the input is, but concatenated on the left with the effect $\star ⤚ \gamma, \gamma ⤚ \star$.

*** Quantification<<sec: quantification>>

To add quantification to the grammar, we'll use an operation $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$, analogous to the identically named operation of \S[[sec:algebraic effects]]. The following definitions of $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$ and its corresponding computation, $\mathtt{scope}^\prime_{(e \rightarrow t) \rightarrow t ⤚ e}$, are determined by the associated parameter and arity.

$$\begin{align*}
\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e} &: ((e \rightarrow t) \rightarrow t) \rightarrow (e \rightarrow \mathcal{F}_l(v)) \rightarrow \mathcal{F}_{(e \rightarrow t) \rightarrow t ⤚ e, l}(v)\\
\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}(q; k) &= \lambda h.h q k\\[3mm]
\mathtt{scope}^\prime_{(e \rightarrow t) \rightarrow t ⤚ e} &: ((e \rightarrow t) \rightarrow t) \rightarrow \mathcal{F}_{(e \rightarrow t) \rightarrow t ⤚ e}(e)\\
\mathtt{scope}^\prime_{(e \rightarrow t) \rightarrow t ⤚ e} q &= \mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}(q; \lambda x.x)\\
&= \lambda h.h q (\lambda x.x)
\end{align*}$$

#+BEGIN_SRC haskell
type Quantifier = (Entity -> Bool) -> Bool

scope :: Operation Quantifier Entity
scope = op

scope' :: Computation Quantifier Entity
scope' = comp
#+END_SRC

The $\mathtt{scope}^\prime_{(e \rightarrow t) \rightarrow t ⤚ e}$ computation thus takes a quantifier meaning $q$ as a parameter and acts, at the level of values, as an entity.

** Handlers

In total we have three operations, $\mathtt{get}_{\star ⤚ \gamma}$, $\mathtt{put}_{\gamma ⤚ \star}$, and $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$; what we need now is a way to handle them. Recall from \S[[sec:algebraic effects]] that handlers have the following shape,

$$\banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N}$$

where $(\mathtt{op}_i : M_i)_{i \in I}$ is some collection of operations in one algebra, associated with the terms which interpret them in another. (Recall that $\eta : N$ means that the handler interprets pure values $v$ as $N v$.) In this subsection, I will outline a general procedure for translating arbitrary handlers with this shape into the simply typed \lambda-calculus in a way compatible with the given encoding of operations and computations. In particular, any given handler will be encoded as a function of type $\mathcal{F}_{l_{in}}(v_{in}) \rightarrow \mathcal{F}_{l_{out}}(v_{out})$ that takes a computation to handle as its input in order to produce an interpretation for that computation in the new algebra as its output. 

It helps to show the encoding of a handler by first representing it as a tuple holding its individual interpreters. Thus we will start by representing an arbitrary handler, as given above, in terms of the following tuple.

$$\langle M_1, \ldots, M_{|I|}, N\rangle$$

The tuple provides a kind of middleman while we build the \lambda-term corresponding to the handler. To encode the handler, we'll need the ability to retrieve the components of this tuple when the encoding requires them. This scheme can be implemented in Haskell in terms of the following class.

#+BEGIN_SRC haskell
-- | The class of handlers whose individual interpreters may be retrieved.
class Retrievable interpreter handler where
  retrieve :: handler -> interpreter
#+END_SRC

The tuple corresponding to a handler has two types of components: those interpreting operations, and one final one interpreting values. In both cases, we wish to interpret the source (operation or value) in some target algebra, i.e., one whose signature is compatible with some predetermined effect $l$. Thus we have the following types for the interpreters which are the components of such a tuple.

#+BEGIN_SRC haskell
-- | A type for operation interpreters.
type InterpretOp p a l v = p -> (a -> F l v) -> F l v

-- | A type for value interpreters.
type InterpretVal l v1 v2 = v1 -> F l v2
#+END_SRC

For our case, we will require a handler that interprets computations from the {$\mathtt{get}_{\star ⤚ \gamma}$, $\mathtt{put}_{\gamma ⤚ \star}$, $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$}-algebra as simpler computations that invoke exactly one $\mathtt{get}_{\star ⤚ \gamma}$ and exactly one $\mathtt{put}_{\gamma ⤚ \star}$; that is, computations whose types are parameterized by the effect $\star ⤚ \gamma, \gamma ⤚ \star$, and which thus have the following shape (where $g^\prime$ is some environment and $v$ is some value, both possibly depending on the input $g$ in some way).

$$\begin{align*}
&\mathtt{get}_{\star ⤚ \gamma}(\star; \lambda g.\mathtt{put}_{\gamma ⤚ \star}(g^\prime; \lambda\star, v))\\
=\ \ &\lambda h.h \star (\lambda g, h^\prime.h^\prime g^\prime (\lambda\star.v))
\end{align*}$$

Such simpler computations are "fully interpreted", insofar as they correspond exactly to computations in the State monad. In particular, the above \lambda-term may be viewed as an alternative notation for the following Stateful program.

$$\lambda g.(v, g^\prime)$$

Accordingly, we will interpret values by simply returning them in (our encoding of) the State monad.

#+BEGIN_SRC haskell
type InterpretStVal v = InterpretVal '[() >-- [Entity], [Entity] >-- ()] v v

-- | Interpret a value.
interpretStVal :: InterpretStVal v
interpretStVal
  = \v -> Impure $ \h -> h () $ \g -> Impure $ \h' -> h' g $ \_ -> Pure v
#+END_SRC

That is, the interpreter for values yields a computation corresponding to the following program, given a value $v$.

$$\lambda g.(v, g)$$

Analogously, the interpreters for operations have the following types.

#+BEGIN_SRC haskell
type InterpretStOp p a v = InterpretOp p a '[() >-- [Entity], [Entity] >-- ()] v

type InterpretStGet v = InterpretStOp () [Entity] v
type InterpretStPut v = InterpretStOp [Entity] () v
type InterpretStScope = InterpretStOp Quantifier Entity Bool
#+END_SRC

An interpreter for $\mathtt{get}_{\star ⤚ \gamma}$, for instance, will be of type $\star \rightarrow (\gamma \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)) \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)$. In particular, we may interpret it as follows.

$$\begin{align*}
\mathtt{interpretStGet} &: \star \rightarrow (\gamma \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)) \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)\\
\mathtt{interpretStGet} &= \lambda\star, k.\mathtt{get}_{\star ⤚ \gamma}(\star; \lambda g.k g (\lambda\star, k^\prime.k^\prime g))\\
(\ &= \lambda\star, k, h.h \star (\lambda g.k g (\lambda\star, k^\prime.k^\prime g))\ \ )
\end{align*}$$

#+BEGIN_SRC haskell
-- | Interpret a 'get' occurrence.
interpretStGet :: InterpretGet v
interpretStGet
  = \_ k -> Impure $ \h -> h () $ \g -> case k g of
                                          Impure m -> m $ \_ k' -> k' g
#+END_SRC

Thus we interpret a $\mathtt{get}_{\star ⤚ \gamma}$ by building a computation of type $\mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)$ that feeds its (interpreted) continuation of type $\gamma \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)$ the first gotten environment of the computation, after which it, again, feeds this environment to the outer $\mathtt{get}_{\star ⤚ \gamma}$  of the result.

The interpretation of $\mathtt{put}_{\gamma ⤚ \star}$ is analagous.

$$\begin{align*}
\mathtt{interpretStPut} &: \gamma \rightarrow (\star \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)) \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(v)\\
\mathtt{interpretStPut} &= \lambda g, k.\mathtt{get}_{\star ⤚ \gamma}(\star; \lambda g^\prime.k \star (\lambda\star, k^\prime.k^\prime g))\\
(\ &= \lambda g, k, h.h \star (\lambda g^\prime.k \star (\lambda\star, k^\prime.k^\prime g))\ \ )
\end{align*}$$

#+BEGIN_SRC haskell
-- | Interpret a 'put' occurrence.
interpretStPut :: InterpretPut v
interpretStPut
  = \g k -> Impure $ \h -> h () $ \_ -> case k () of
                                          Impure m -> m $ \_ k' -> k' g
#+END_SRC

In this case, the $\mathtt{put}_{\gamma ⤚ \star}$ occurrence is interpreted by plugging its (interpreted) continuation with $\star$ and then feeding the environment it puts to the outer $\mathtt{get}_{\star ⤚ \gamma}$ of the result. Doing so ensures that $\mathtt{put}_{\gamma ⤚ \star}$ has the required effect on the resulting computation; i.e., that of dictating its input.

Finally, we have the following interpretation for $\mathtt{scope}_{(e \rightarrow t) \rightarrow t ⤚ e}$.

$$\begin{align*}
\mathtt{interpretStScope} &: ((e \rightarrow t) \rightarrow t) \rightarrow (e \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(t)) \rightarrow \mathcal{F}_{\star ⤚ \gamma, \gamma ⤚ \star}(t)\\
\mathtt{interpretStScope} &= \lambda g, k.\mathtt{get}_{\star ⤚ \gamma}(\star; \lambda g^\prime.k \star (\lambda\star, k^\prime.k^\prime g))\\
(\ &= \lambda g, k, h.h \star (\lambda g^\prime.k \star (\lambda\star, k^\prime.k^\prime g))\ \ )
\end{align*}$$

#+BEGIN_SRC haskell
-- | Interpret a 'scope' occurrence.
interpretStScope :: InterpretScope
interpretStScope
  = \q k ->
  Impure $ \h -> h () $ \g ->
  Impure $ \h' -> h' g $ \_ ->
  Pure $ q $ \x -> case k x of
                     Impure m -> m $ \_ k' ->
                       case k' g of
                         Impure m' -> m' $ \_ k'' ->
                           case k'' () of
                             Pure a -> a
#+END_SRC

* A linguistic example<<sec:a linguistic example>>

$\begin{align*}
\IF{\textit{some linguist}} &: \mathcal{F}_{((e \rightarrow t) \rightarrow t)⤚ e} e\\
\IF{\textit{some linguist}} &= \mathtt{scope}_{((e \rightarrow t) \rightarrow t) ⤚ e}(\lambda P.\exists x : \textbf{ling} x\ \&\ P x; \eta)\\
&= \lambda h.h\ (\lambda P.\exists x : \textbf{ling} x\ \&\ P x)\ (\lambda y.y)\\[2mm]
\IF{\textit{her dog}} &: \mathcal{F}_{() ⤚ \gamma} e\\
\IF{\textit{her dog}} &= \mathtt{get}_{() ⤚ \gamma}((); \lambda g.\eta (\textbf{dogOf} (\mathtt{sel} g)))\\
&= \lambda h.h\ ()\ (\lambda g, k.k (\textbf{dogOf} (\mathtt{sel} g)))\\[2mm]
(\cdot)^\triangleright &: \mathcal{F}_l e \rightarrow \mathcal{F}_{l, () ⤚ \gamma, \gamma ⤚ ()} e\\
m^\triangleright &\defeq m \bind (\lambda x.\mathtt{get}_{() ⤚ \gamma}((); \lambda g.\mathtt{put}_{\gamma ⤚ ()}(\append{x}{g}; \lambda ().\eta x)))\\
&= m \bind \lambda x, h.h\ ()\ (\lambda g, h^\prime.h^\prime\ (\append{x}{g})\ (\lambda ().x)) 
\end{align*}$

$\begin{align*}
(\triangleright) &: \mathcal{F}_{l_1} (v \rightarrow w) \rightarrow \mathcal{F}_{l_2} v \rightarrow \mathcal{F}_{l_1, l_2} w\\
m \triangleright n &\defeq \mu\ (\mathtt{map}\ (\lambda f.\mathtt{map}\ (\lambda x.f x)\ n)\ m)\\[2mm]
(\triangleleft) &: \mathcal{F}_{l_1} v \rightarrow \mathcal{F}_{l_2} (v \rightarrow w) \rightarrow \mathcal{F}_{l_1, l_2} w\\
m \triangleleft n &\defeq \mu\ (\mathtt{map}\ (\lambda x.\mathtt{map}\ (\lambda f.f x)\ n)\ m)
\end{align*}$

#+BEGIN_SRC haskell
(|>) :: F l1 (v -> w) -> F l2 v -> F (l1 :++ l2) w
m |> n = join $ fmap (\f -> fmap (\x -> f x) n) m

(<|) :: F l1 v -> F l2 (v -> w) -> F (l1 :++ l2) w
m <| n = join $ fmap (\x -> fmap (\f -> f x) n) m
#+END_SRC

#+BIBLIOGRAPHY: algebraic_effects_montague apalike
